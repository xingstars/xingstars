

#include "PfcCalculation.h"
#include "MosMillData.h"
#include "MosStripData.h"
#include "MosAcMillData.h"
#include "CalcUtil.h"
#include "MosEnv.h"
#include "MosAlloyCom.h"
#include "MosAlloy.h"
#include "ScDef.h"
#include "ScCalcCor.h"
#include "ScError.h"
#include "PfcAdaptDebugDef.hpp"

PfcCalculation::PfcCalculation()
    : m_setup(NULL),
    m_wrapper(NULL),
    m_chainNumber(0)
{
  deB = new Dbg();
  short returnW = PSC_OK;

  pfcMill = MosMillData::GetInstance();
  if (pfcMill == NULL)
  {
    DE_BUG << "create own pfcMill data fault BREAK" << ERR;
  }
  else
  {
    DE_BUG << "create own pfcMill data ok" << INFO;
  }

  pfcStrip = MosStripData::GetInstance();
  if (pfcStrip == NULL)
  {
    DE_BUG << "create own pfcStrip data fault BREAK" << ERR;
  }
  else
  {
    DE_BUG << "create own pfcStrip data ok" << INFO;
  }

  acMill = MosAcMillData::GetInstance();
  if (acMill == NULL)
  {
    DE_BUG << "create own acMill data fault BREAK" << ERR;
  }
  else
  {
    DE_BUG << "create own acMill data ok" << INFO;
  }

  mosEnv = new MosEnv();
  calcUtil = new CalcUtil();
  m_wrapper = new CusPfcWrapper;
  if (!m_wrapper)
    throw_BCException("failed to construct PFC wrapper object");

  // initialize the setup model pointer
  m_setup = m_wrapper->getSetupModel();

  // set alloy utilitys
  mosAlloy  = new MosAlloyUtil();

  // pfc strip data
  strip = new MFStrip;

  // loop all stands
  for (int sn = 0; sn < MAX_NO_STANDS; sn++)
  {
    workRollData   [sn] = new PFCRoll;
    backUpRollData [sn] = new PFCRoll;
  }// end loop all stands
}

////////////////////////////////////////////////////////////////////////////////
// destructor
PfcCalculation::~PfcCalculation()
{
  // delete all pointers
  delete deB     ;
  delete mosEnv  ;
  delete calcUtil;

  delete mosAlloy;
  delete strip   ;

  // if (m_setup != NULL) delete m_setup;

  for (int sn = 0; sn < MAX_NO_STANDS; sn++)
  {
    delete workRollData   [sn] ;
    delete backUpRollData [sn]  ;
  }
}

bool PfcCalculation :: setPfcAcRollData()
{
  short returnW = PSC_OK;

  try
  {
    // set pointer
    DmTwOutRoll      * twRollWR   ;
    DmTwOutRoll      * twRollBR   ;
    DmAcStandVal     * acStand    ;

    double tmCrown[MAX_NO_STANDS][MAX_NO_ROLLS][MAX_NO_TM_DISKS_PC] ;
    double wmCrown[MAX_NO_STANDS][MAX_NO_ROLLS][MAX_NO_WM_DISKS_PC] ;

    int loopCount = MAX_NO_WM_DISKS_PC;
    if (MAX_NO_TM_DISKS_PC > MAX_NO_WM_DISKS_PC)
      loopCount = MAX_NO_TM_DISKS_PC;

    // preset twm crown for all stands and all rolls
    for (int sn = 0; sn < MAX_NO_STANDS ; sn++)
    {
      // set TWM data
      twRollWR = acMill->getPtrAcValues()->getPtrTwOut()->getPtrTwOutStand(sn)->getPtrTwOutRoll(WR);
      twRollBR = acMill->getPtrAcValues()->getPtrTwOut()->getPtrTwOutStand(sn)->getPtrTwOutRoll(BR);

      for (int dn = 0; dn < loopCount; dn++)
      {
        if (dn < MAX_NO_TM_DISKS_PC)
        {
          // set tm crown
          tmCrown[sn][WR][dn] = (double) twRollWR->tcrown(dn);
          tmCrown[sn][BR][dn] = (double) twRollBR->tcrown(dn);
        }
        if (dn < MAX_NO_WM_DISKS_PC)
        {
          // set wm crown
          wmCrown[sn][WR][dn] = (double) twRollWR->wcrown(dn);
          wmCrown[sn][BR][dn] = (double) twRollBR->wcrown(dn);
        }
      }
    }

    // set the work roll data
    for (unsigned int sn = 0; sn < MAX_NO_STANDS ; sn++)
    {
      twRollWR = acMill->getPtrAcValues()->getPtrTwOut()->getPtrTwOutStand(sn)->getPtrTwOutRoll(WR);

      workRollData[sn]->setThermalCrown(&tmCrown[sn][WR][0], &tmCrown[sn][WR][twRollWR->tmNoDisks()]);
      workRollData[sn]->setWearCrown(&wmCrown[sn][WR][0], &wmCrown[sn][WR][twRollWR->wmNoDisks()]);

      // set bending shifting from PC we have actual value and operatot input
      acStand = acMill->getPtrAcValues()->getPtrAcStandVal(sn);

      m_setup->getStand(sn).setBendingForces(acStand->getPtrBendingForce()->value());
      m_setup->getStand(sn).setRollShift((int) (acStand->getPtrShiftRoll()->value() * 1000.));

      // --> take over roll data for setup calculation
      m_setup->setRollData(sn, 0, *workRollData[sn]);

      // set TWM data
      twRollBR = acMill->getPtrAcValues()->getPtrTwOut()->getPtrTwOutStand(sn)->getPtrTwOutRoll(BR);

      // set TWM DATA
      backUpRollData[sn]->setThermalCrown(&tmCrown[sn][BR][0], &tmCrown[sn][BR][twRollBR->tmNoDisks()]);
      backUpRollData[sn]->setWearCrown(&wmCrown[sn][BR][0], &wmCrown[sn][BR][twRollBR->wmNoDisks()]);

      // --> take over roll data for setup calculation
      m_setup->setRollData(sn, 1, *backUpRollData[sn]);
    }
  }
  catch (BCException& ex)
  {
    DE_BUG << "caught error preset pfc ac roll data: " << ex.what() << ERR;
    pfcStrip->setCalcFault(SetAcRollData, UNDEF_STAND);
    return false;
  }
  catch (...)
  {
    DE_BUG << "caught unknown error pfc ac roll data: " << ERR;
    pfcStrip->setCalcFault(SetAcRollData, UNDEF_STAND);
    return false;
  }
  return true;
}

bool PfcCalculation::setPfcRollData()
{
  short returnW = PSC_OK;

  try
  {
    BCTinyVector<double, MAX_NO_SHAPE_EXP, 0> shape(MAX_NO_SHAPE_EXP, 0.0);
    DmRollDataStand  * rollStand;
    DmRollData       * rollData ;
    DmRollClass      * rollClass;
    DmRollProperty   * rollProp ;
    DmPlantDataStand * plantStand ;

    // set the work roll data
    for (unsigned int sn = 0; sn < MAX_NO_STANDS ; sn++)
    {
      workRollData[sn]->setRollType(MFRoll::WorkRoll);

      rollStand = pfcMill->getStandRollPtr(sn);

      rollData  = rollStand->getPtrRollData(WR_T)  ;
      rollClass = rollStand->getPtrRollClass(WR)   ;
      rollProp  = rollStand->getPtrRollProperty(WR);

      plantStand = pfcMill->getPtrStandData(sn)->getPtrPlantDataStand();

      // roll id
      BCString id(rollData->rollId());
      workRollData[sn]->setRollId(id);

      // [m] radius
      workRollData[sn]->setRadius(rollData->diameter() / 2.);
      // [m] roll length
      workRollData[sn]->setLength(rollClass->length());

      // [m] neck length
      workRollData[sn]->setNeckLength(rollClass->lNeck());
      // [m] neck radius
      workRollData[sn]->setNeckRadius(rollClass->dNeck() / 2.);

      // [N/m2] emod core
      workRollData[sn]->setYoungsModulusCore(rollProp->emodIn());
      // [N/m2] emod surface
      workRollData[sn]->setYoungsModulusSurf(rollProp->emodOut());

      // set cone parameters
      workRollData[sn]->setConeLength(0, rollClass->lCone(0));
      workRollData[sn]->setConeLength(1, rollClass->lCone(1));
      workRollData[sn]->setConeHeight(0, rollClass->hCone(0));
      workRollData[sn]->setConeHeight(1, rollClass->hCone(1));
      workRollData[sn]->setConeDist(0  , rollClass->stCone(0));
      workRollData[sn]->setConeDist(1  , rollClass->stCone(1));
      workRollData[sn]->setConeType(rollClass->coneType());

      // set grinding type ( 1 = polynomial, 2 = taper roll, 3 = invalid grinding )
      workRollData[sn]->setGrindingType(1);
      workRollData[sn]->setBendingAllowed(plantStand->bendingAl(WR));

      // set shifting allowed only for CVC rolls (check cyclic shift)
      workRollData[sn]->setShiftingAllowed(plantStand->shiftingAl(WR)); 

      // set shape exp
      for (int ns = 0; ns < MAX_NO_SHAPE_EXP ; ns++)
        shape[ns] = 0.;

      if (rollData->shapeX1Zi() != ZI_VALUE_NOT_AVAILABLE)
        shape[0] = rollData->shapeX1()   ;
      if (rollData->shapeX2Zi() != ZI_VALUE_NOT_AVAILABLE)
        shape[1] = rollData->shapeX2()   ;
      if (rollData->shapeX3Zi() != ZI_VALUE_NOT_AVAILABLE)
        shape[2] = rollData->shapeX3()   ;
      if (rollData->shapeX4Zi() != ZI_VALUE_NOT_AVAILABLE)
        shape[3] = rollData->shapeX4()   ;
      if (rollData->shapeX5Zi() != ZI_VALUE_NOT_AVAILABLE)
        shape[4] = rollData->shapeX5()   ;
      if (rollData->shapeX6Zi() != ZI_VALUE_NOT_AVAILABLE)
        shape[5] = rollData->shapeX6()   ;
      if (rollData->shapeX7Zi() != ZI_VALUE_NOT_AVAILABLE)
        shape[6] = rollData->shapeX7()   ;
      if (rollData->shapeX8Zi() != ZI_VALUE_NOT_AVAILABLE)
        shape[7] = rollData->shapeX8()   ;
      if (rollData->shapeX9Zi() != ZI_VALUE_NOT_AVAILABLE)
        shape[8] = rollData->shapeX9()   ;

      workRollData[sn]->setShapeCoefficients(shape);
      this->m_LimitFromRollData[sn] = false;

      // set / reset shifting allowed
      if ((shape[0] == 0.) && (shape[2] == 0.) || (plantStand->shiftingAl(WR) == 0))
      {
        workRollData[sn]->setShiftingAllowed(0);
        this->m_LimitFromRollData[sn]     = true;
        this->m_ShiftLimitRollData[sn]    = 0.;
      }
      workRollData[sn]->setDistPC(plantStand->disPressAction(WR));

      // --> take over roll data for setup calculation
      DE_BUG << "WR[" << sn << "]:" << workRollData[sn]->getRollId()
             << " rollclass " << rollData->rollClass()
             << " length " << rollClass->length()
             << " emodout " << rollProp->emodOut()
             << " Shape: "  << shape[0] << " " << shape[1] << " " << shape[2] << " " << shape[3] << " " << shape[4] << " " << shape[5] << " " << shape[6] << " " << shape[7] << " " << shape[8]
        << INFO;

      m_setup->setRollData(sn, 0, *workRollData[sn]);
    }

    // set the backup roll data
    for (unsigned int sn = 0; sn < MAX_NO_STANDS; sn++)
    {
      backUpRollData[sn]->setRollType(MFRoll::BackupRoll);
      rollStand = pfcMill->getStandRollPtr(sn);

      rollData  = rollStand->getPtrRollData(BR_T)  ;
      rollClass = rollStand->getPtrRollClass(BR)   ;
      rollProp  = rollStand->getPtrRollProperty(BR);
      plantStand = pfcMill->getPtrStandData(sn)->getPtrPlantDataStand();

      // roll id
      BCString id ( rollData->rollId() );
      backUpRollData[sn]->setRollId ( id );

      // [m] radius
      backUpRollData[sn]->setRadius(rollData->diameter() / 2.);
      // [m] roll length
      backUpRollData[sn]->setLength(rollClass->length());

      // [m] neck length
      backUpRollData[sn]->setNeckLength(rollClass->lNeck());
      // [m] neck radius
      backUpRollData[sn]->setNeckRadius(rollClass->dNeck() / 2.);

      // [N/m2] emod core
      backUpRollData[sn]->setYoungsModulusCore(rollProp->emodIn());
      // [N/m2] emod surface
      backUpRollData[sn]->setYoungsModulusSurf(rollProp->emodOut());

      // set cone parameters
      backUpRollData[sn]->setConeLength(0, rollClass->lCone(0));
      backUpRollData[sn]->setConeLength(1, rollClass->lCone(1));
      backUpRollData[sn]->setConeHeight(0, rollClass->hCone(0));
      backUpRollData[sn]->setConeHeight(1, rollClass->hCone(1));
      backUpRollData[sn]->setConeDist(0  , rollClass->stCone(0));
      backUpRollData[sn]->setConeDist(1  , rollClass->stCone(1));
      backUpRollData[sn]->setConeType(rollClass->coneType());

      // set the grinding type ( 1 = polynomial, 2 = taper roll, 3 = invalid grinding )
      backUpRollData[sn]->setGrindingType(1);

      backUpRollData[sn]->setBendingAllowed(0);
      backUpRollData[sn]->setShiftingAllowed(0);

      // set shape exp
      for (int ns = 0; ns < MAX_NO_SHAPE_EXP ; ns++)
        shape[ns] = 0.;

      if (rollData->shapeX1Zi() != ZI_VALUE_NOT_AVAILABLE)
        shape[0] = rollData->shapeX1()   ;
      if (rollData->shapeX2Zi() != ZI_VALUE_NOT_AVAILABLE)
        shape[1] = rollData->shapeX2()   ;
      if (rollData->shapeX3Zi() != ZI_VALUE_NOT_AVAILABLE)
        shape[2] = rollData->shapeX3()   ;
      if (rollData->shapeX4Zi() != ZI_VALUE_NOT_AVAILABLE)
        shape[3] = rollData->shapeX4()   ;
      if (rollData->shapeX5Zi() != ZI_VALUE_NOT_AVAILABLE)
        shape[4] = rollData->shapeX5()   ;
      if (rollData->shapeX6Zi() != ZI_VALUE_NOT_AVAILABLE)
        shape[5] = rollData->shapeX6()   ;
      if (rollData->shapeX7Zi() != ZI_VALUE_NOT_AVAILABLE)
        shape[6] = rollData->shapeX7()   ;
      if (rollData->shapeX8Zi() != ZI_VALUE_NOT_AVAILABLE)
        shape[7] = rollData->shapeX8()   ;
      if (rollData->shapeX9Zi() != ZI_VALUE_NOT_AVAILABLE)
        shape[8] = rollData->shapeX9()   ;

      backUpRollData[sn]->setShapeCoefficients(shape);

      m_setup->getStand(sn).setRollShift(0.);

      backUpRollData[sn]->setDistPC(plantStand->disPressAction(BR));

      // --> take over roll data for setup calculation
      m_setup->setRollData(sn, 1, *backUpRollData[sn]);
    }
  }  
  catch (BCException& ex)
  {
    DE_BUG << "caught error preset pfc roll data: " << ex.what() << ERR;
    pfcStrip->setCalcFault(SetRollData, UNDEF_STAND,"pfc rolldata");
    return false;
  }
  catch (...)
  {
    DE_BUG << "caught unknown error pfc roll data: " << ERR;
    pfcStrip->setCalcFault(SetRollData, UNDEF_STAND,"pfc rolldata");
    return false;
  }
  return true;
}

short PfcCalculation::setPfcStripData()
{
  short returnW = PSC_OK;
  DmPrimaryData    * stripData    = pfcStrip->getPtrPrimaryData()->getPtrStripData();
  DmCalcResMill    * calcMill     = pfcStrip->getPtrCalcRes()->getPtrCalcResMill()  ;
  DmMosParamMill   * mosParamMill = pfcMill->getPtrMosParamMill()                   ;

  // data structures for the model inputs
  static BCTinyVector<double, PFC_MAX_NO_RM_PROFILE, 0> entryProfile(PFC_MAX_NO_RM_PROFILE, 0.0);
  static BCTinyVector<double, PFC_MAX_NO_RM_PROFILE, 0> entryProfilePoints(PFC_MAX_NO_RM_PROFILE, 0.0);
  static BCTinyVector<double, PFC_MAX_NO_RM_PROFILE, 0> entryFlatness(PFC_MAX_NO_RM_PROFILE, 0.0);

  try
  {
        // build the z-discretization used outside the MF model
    const int Nz = MF::NoPointsInterpolator;
    const int Ncenter = (Nz - 1) / 2;
    double halfStripWidth = 0.5 * calcMill->getPtrRMExitValues()->getPtrExitWidthRm()->getPtrWidth()->valueHot();
    double dz = 2.0 * halfStripWidth / Nz;
    static BCTinyVector<double, MF::NoPointsInterpolator, 0> zPoints ( Nz, 0.0 );
    linspace(zPoints, -halfStripWidth, halfStripWidth, Nz);
    double thickness = calcMill->getPtrRMExitValues()->getPtrExitThickRm()->getPtrThickness()->valueHot();

        // compute estimate for the roughed strip profile (parabola centered at
        // strip center, absolute profile)
    static BCTinyVector<double, MF::NoPointsInterpolator, 0> profile ( Nz, 0.0 );
    for (unsigned int i = 0; i < profile.size(); i++)
      profile[i] = 0.0;

    // initialize entry flatness
    strip->getUnflatness().init(zPoints, profile, true);

    // entry strip profile (miele_040207: take edge distance into account)
    double cpos = 40. / 1000.;
    double cposNormal = cpos / halfStripWidth;
    double pIn = (0.4 / 100) * thickness;
    pIn = (-1.0) * pIn  / ((1.0 - cposNormal) * (1.0 - cposNormal));

    BCTinyPolynomial<double, 2> epPoly;
    epPoly.setCoefficient(2, pIn);

    for (unsigned int j = 0; j < profile.size(); j++)
      profile[j] = epPoly(zPoints[j] / halfStripWidth);
    strip->getProfile().init(zPoints, profile, true);
    strip->setYoungsModulus(mosParamMill->stripYoungstModule());

    // mean tension
    strip->setMeanTension(2e7);

    // [m/s] entry speed
    strip->setSpeed(calcMill->fMEntryStripSpeed());
    // [m]   entry thickness hot value
    strip->setHalfThickness(calcMill->getPtrRMExitValues()->getPtrExitThickRm()->thickValueHotFmEntry() / 2.);
    // [m]   entry width
    strip->setWidth(2.0*halfStripWidth);
    // [-]   strip id (exd id)
    strip->setStripId(pfcStrip->getPtrCalcRes()->meCode().extId);

    strip->setAlloyCode(stripData->alloyCode());

    // insert strip data
    m_setup->setStripData(0, *strip);

    // pointer results pass
    DmCalcResPass * calcPass;

    for (int pn = 0; pn < MAX_NO_PASSES ; pn++)
    {
      // calculation results
      calcPass = pfcStrip->getPtrCalcRes()->getPtrCalcResPass(pn);

      // youngst modulus
      strip->setYoungsModulus(mosParamMill->stripYoungstModule());

      // mean tension ???? entry or exit
      strip->setMeanTension(2e7);

      // [m] exit thickness pass
      strip->setHalfThickness(calcPass->exitThickness() / 2.);

      // [m/s] exit speed strip
      strip->setSpeed(calcPass->exitStripSpeed());

      // [m]   exit width
      strip->setWidth(2.0*halfStripWidth);

      // [-]   strip id ( ext id )
      strip->setStripId(pfcStrip->getPtrCalcRes()->meCode().extId);

      // insert strip data
      m_setup->setStripData(pn + 1, *strip);
    }

    *deB << "Target Profile from STRIP DATA: " << pfcStrip->getPtrCalcRes()->getPtrCalcResMill()->fMExitProfileSetp();
    deB->info();

    *deB << "Thickness: ";
    for(int pn=0; pn<MAX_NO_PASSES; pn++)
      *deB << m_setup->getStrip(pn).getHalfThickness() << " ";
    deB->info();

    // set the target profile  STRIP DATA
    m_setup->setTargetProfile(pfcStrip->getPtrCalcRes()->getPtrCalcResMill()->fMExitProfileSetp());
  }
  catch (BCException& ex)
  {
    DE_BUG << "caught error preset pfc strip data: " << ex.what() << ERR;
    pfcStrip->setCalcFault(SetStripData, UNDEF_STAND,"pfc stripdata");
    return PSC_ERROR * SetStripData;
  }
  catch (...)
  {
    DE_BUG << "caught unknown error pfc strip data: " << ERR;
    pfcStrip->setCalcFault(SetStripData, UNDEF_STAND,"pfc stripdata");
    return PSC_ERROR * SetStripData;
  }
  return returnW;
}

short PfcCalculation::setPfcPlantLimit()
{
  short returnW = PSC_OK;
  DmLimitDataStand * limitStand;
  MosAcMillData *acMill = MosAcMillData::GetInstance();

  try
  {
    *deB << "BalancingForce: ";
    for (int an = 0; an < MAX_NO_STANDS; an++)
      *deB << pfcMill->getPtrStandData(an)->getPtrPlantDataStand()->balanceForce() << " ";
    deB->info();

    for (unsigned int sn = 0; sn < MAX_NO_STANDS; sn++)
    {
      limitStand = pfcMill->getPtrStandData(sn)->getPtrLimitStand();

      double balanceForce = pfcMill->getPtrStandData(sn)->getPtrPlantDataStand()->balanceForce();
      if (sn > (unsigned int) pfcStrip->getPtrCalcRes()->getPtrCalcResMill()->noLas() - 3)
      {
        double delta;
        delta = limitStand->maxBendForce() - limitStand->minBendForce();
        if (delta > 0)
        {
          delta *= 0.1;
        }
        else
        {
          delta = 0;
        }
        limits.m_lowerLimitsBending[sn] = (limitStand->minBendForce() + delta + balanceForce);
        limits.m_upperLimitsBending[sn] = (limitStand->maxBendForce() - delta + balanceForce);
      }
      else
      {
        limits.m_lowerLimitsBending[sn] = (limitStand->minBendForce() + balanceForce);
        limits.m_upperLimitsBending[sn] = (limitStand->maxBendForce() + balanceForce);
      }

      // if rollForce is smaller than the lower bending limit, then change the bending limit  //andrea_110702
      if ( pfcStrip->getPtrCalcRes()->getPtrCalcResPass(sn)->rollForce() + limitStand->minBendForce() < 0 )
      {
        *deB << "rollForce - lowerBendingLimit < 0  ->  change lowerBendingLimit from " << limits.m_lowerLimitsBending[sn];
        limits.m_lowerLimitsBending[sn] = ( -1*pfcStrip->getPtrCalcRes()->getPtrCalcResPass(sn)->rollForce() + balanceForce);
        *deB << " to " << limits.m_lowerLimitsBending[sn];
        *deB << " in Stand " << sn;
        deB->info();
      }

      // only for testing Ra_090206
      DmPlantDataStand * plantStand ;

      plantStand = pfcMill->getPtrStandData(sn)->getPtrPlantDataStand();

      // Mic 20070322 add calcType-specific limits for work roll shifting
      if ( pfcStrip->getPtrCalcRes()->calcTypeMos() == 4 && !m_setup->getShiftStrategy(sn) && plantStand->shiftingAl(WR) )
      {
        double actShiftPos = 0;
        if (acMill->getPtrAcValues()->getPtrAcStandVal(sn)->getPtrShiftRoll()->noCycl() > 0)
        {
          actShiftPos = acMill->getPtrAcValues()->getPtrAcStandVal(sn)->getPtrShiftRoll()->value();
        }
        else
        {
          actShiftPos = pfcStrip->getPtrCalcRes()->getPtrCalcResPass(sn)->rollShift();
        }

        double deltaShift = 0.002;
        DE_BUG << "Mic: shift: " << sn
        << " act: " << actShiftPos * 1.e3
        << " +-: " << deltaShift * 1.e3
        << INFO;

        // Mic 20070322 set to the former values with a small range to adjust
        if ((actShiftPos - deltaShift) > limitStand->minShiftingPos())
        {
          limits.m_lowerLimitsShift[sn]            = (actShiftPos - deltaShift) * 1.e3;
        }
        else
        {
          limits.m_lowerLimitsShift[sn]            = this->m_LimitFromRollData[sn] ? this->m_ShiftLimitRollData[sn] : limitStand->minShiftingPos() * 1.e3;
        }

        // Mic 20070322 set to the former values with a small range to adjust
        if ((actShiftPos + deltaShift) < limitStand->maxShiftingPos())
        {
          limits.m_upperLimitsShift[sn]            = (actShiftPos + deltaShift) * 1.e3;
        }
        else
        {
          limits.m_upperLimitsShift[sn]            = this->m_LimitFromRollData[sn] ? this->m_ShiftLimitRollData[sn] : limitStand->maxShiftingPos() * 1.e3;
        }

        DE_BUG << "Mic: shift: new limits: LL: " << limits.m_lowerLimitsShift[sn] << " UL: " << limits.m_upperLimitsShift[sn] << INFO;
      }
      else
      {
        // [m] limit work roll shift
        limits.m_lowerLimitsShift[sn]            = this->m_LimitFromRollData[sn] ? this->m_ShiftLimitRollData[sn] : limitStand->minShiftingPos() * 1.e3;
        limits.m_upperLimitsShift[sn]            = this->m_LimitFromRollData[sn] ? this->m_ShiftLimitRollData[sn] : limitStand->maxShiftingPos() * 1.e3;
      }


      limits.m_lowerLimitsPairCross[sn]            = 0.0;
      limits.m_upperLimitsPairCross[sn]            = 0.0;

      limits.m_currentLowerLimitsBending[sn]   = limits.m_lowerLimitsBending[sn] + balanceForce;
      limits.m_currentUpperLimitsBending[sn]   = limits.m_upperLimitsBending[sn] + balanceForce;

      // limit work roll shift
      limits.m_currentLowerLimitsShift[sn]     = limits.m_lowerLimitsShift[sn];
      limits.m_currentUpperLimitsShift[sn]     = limits.m_upperLimitsShift[sn];
      limits.m_currentLowerLimitsPairCross[sn]     = limits.m_lowerLimitsPairCross[sn];
      limits.m_currentUpperLimitsPairCross[sn]     = limits.m_upperLimitsPairCross[sn];
      m_setup->getStand(sn).setPairCrossLimits(limits.m_lowerLimitsPairCross[sn], limits.m_upperLimitsPairCross[sn]);
    }
    m_setup->initLimits(limits);
  }
  catch (BCException& ex)
  {
    DE_BUG << "caught error preset pfc limit data: " << ex.what() << ERR;
    pfcStrip->setCalcFault(SetLimitData, UNDEF_STAND, "pfc limits");
    return PSC_ERROR * SetLimitData;
  }
  catch (...)
  {
    DE_BUG << "caught unknown error pfc limit data: " << ERR;
    pfcStrip->setCalcFault(SetLimitData, UNDEF_STAND, "pfc limits");
    return PSC_ERROR * SetLimitData;
  }
  return returnW;
}

short PfcCalculation::setPfcChemistry()
{
  short returnW = PSC_OK;
  DmPrimaryData * stripData    = pfcStrip->getPtrPrimaryData()->getPtrStripData();

  try
  {
    AlloyComp alloyComp(stripData->alloyNo()
                        , stripData->alloyName()
                        , stripData->alloyNameZi()
                        , stripData->alloyValue()
                        , stripData->alloyValueZi()
                       );

    // sort alloy elements
    if (returnW = mosAlloy->alloyCompSort(alloyComp))
      return returnW;

    // set alloy components / new
    //double alloy_c    = alloyComp.valueElem(mosAlloy->getArrayNo("C"));
    double alloy_cr   = alloyComp.valueElem(mosAlloy->getArrayNo("Cr"));
    double alloy_mn   = alloyComp.valueElem(mosAlloy->getArrayNo("Mn"));
    double alloy_si   = alloyComp.valueElem(mosAlloy->getArrayNo("Si"));
    double alloy_ni   = alloyComp.valueElem(mosAlloy->getArrayNo("Ni"));
    double alloy_cu   = alloyComp.valueElem(mosAlloy->getArrayNo("Cu"));
    double alloy_b    = alloyComp.valueElem(mosAlloy->getArrayNo("B "));
    double alloy_be   = alloyComp.valueElem(mosAlloy->getArrayNo("Be"));
    double alloy_ca   = alloyComp.valueElem(mosAlloy->getArrayNo("Ca"));
    double alloy_fe   = alloyComp.valueElem(mosAlloy->getArrayNo("Fe"));
    double alloy_mg   = alloyComp.valueElem(mosAlloy->getArrayNo("Mg"));
    double alloy_na   = alloyComp.valueElem(mosAlloy->getArrayNo("Na"));
    double alloy_ti   = alloyComp.valueElem(mosAlloy->getArrayNo("Ti"));
    double alloy_zn   = alloyComp.valueElem(mosAlloy->getArrayNo("Zn"));

    // correction of the chemistry data to avoid -1 for NN
    //chemistry.m_c    = (alloy_c < 0.0 ? 0.0 : alloy_c);
    chemistry.m_cr   = (alloy_cr < 0.0 ? 0.0 : alloy_cr);
    chemistry.m_mn   = (alloy_mn < 0.0 ? 0.0 : alloy_mn);
    chemistry.m_si   = (alloy_si < 0.0 ? 0.0 : alloy_si);
    chemistry.m_ni   = (alloy_ni < 0.0 ? 0.0 : alloy_ni);
    chemistry.m_cu   = (alloy_cu < 0.0 ? 0.0 : alloy_cu);
    chemistry.m_b    = (alloy_b < 0.0 ? 0.0 : alloy_b);
    chemistry.m_be   = (alloy_be < 0.0 ? 0.0 : alloy_be);
    chemistry.m_ca   = (alloy_ca < 0.0 ? 0.0 : alloy_ca);
    chemistry.m_fe   = (alloy_fe < 0.0 ? 0.0 : alloy_fe);
    chemistry.m_mg   = (alloy_mg < 0.0 ? 0.0 : alloy_mg);
    chemistry.m_na   = (alloy_na < 0.0 ? 0.0 : alloy_na);
    chemistry.m_ti   = (alloy_ti < 0.0 ? 0.0 : alloy_ti);
    chemistry.m_zn   = (alloy_zn < 0.0 ? 0.0 : alloy_zn);

    try
    {

      double alloyTi = alloyComp.valueElem(mosAlloy->getArrayNo("Ti"));
      DE_BUG << "Mic: alloyTi = " << alloyTi << INFO;

      double alloyV  = 0.0;
      try
      {
        alloyV = alloyComp.valueElem(mosAlloy->getArrayNo("V "));
      }
      catch (...)
      {
        alloyV = alloyComp.valueElem(mosAlloy->getArrayNo("V"));
      }
      DE_BUG << "Mic: alloyV = " << alloyV << INFO;

      double alloyNb = alloyComp.valueElem(mosAlloy->getArrayNo("Nb"));
      DE_BUG << "Mic: alloyNb = " << alloyNb << INFO;

      chemistry.m_hsla = (alloyTi < 0.0 ? 0.0 : alloyTi)
                         + (alloyV  < 0.0 ? 0.0 : alloyV)
                         + (alloyNb < 0.0 ? 0.0 : alloyNb);

      DE_BUG << "chemistry: " << "C: " << chemistry.m_c 
                              << " Cr: " << chemistry.m_cr
                              << " Mn: " << chemistry.m_mn 
                              << " Si: " << chemistry.m_si
                              << " Ni: " << chemistry.m_ni 
                              << " Hsla: " << chemistry.m_hsla 
                              << " B: " << chemistry.m_b
                              << " Be: " << chemistry.m_be
                              << " Ca: " << chemistry.m_ca
                              << " Fe: " << chemistry.m_fe
                              << " Mg: " << chemistry.m_mg
                              << " Na: " << chemistry.m_na
                              << " Ti: " << chemistry.m_ti
                              << " Zn: " << chemistry.m_zn  
                              << INFO;

    }
    catch (...)
    {
      DE_BUG << "error getting HSLA chemistry component; using 0.0" << ERR;
      chemistry.m_hsla = 0.0;
    }
    if (chemistry.m_hsla < 0)
      chemistry.m_hsla = 0.0;

    sprintf(chemistry.m_alloyCode,stripData->alloyCode());

    DE_BUG << "alloy code for inheritance: " << chemistry.m_alloyCode << INFO;
    m_wrapper->getSetupModel()->setChemistry(chemistry);

  }
  catch (BCException& ex)
  {
    DE_BUG << "caught error preset pfc limit data: " << ex.what() << ERR;
    pfcStrip->setCalcFault(SetLimitData, UNDEF_STAND, "pfc limit");
    return PSC_ERROR * SetLimitData;
  }
  catch (...)
  {
    DE_BUG << "caught unknown error pfc limit data: " << ERR;
    pfcStrip->setCalcFault(SetLimitData, UNDEF_STAND, "pfc limit");
    return PSC_ERROR * SetLimitData;
  }
  return returnW;
}

short PfcCalculation::setPfcCalcRes()
{
  short returnW = PSC_OK;
  int   sn      = 0     ;

  DmCalcResPass    * calcResPass ;
  DmCalcResStand   * calcResStand;
  DmPlantDataStand * plantStand  ;

  try
  {

    *deB << "Fr: rollForce() rollForcePre() rollForceHead() ";
    deB->info();

    for (unsigned int pn = 0; pn < MAX_NO_PASSES; pn++)
    {
      calcResPass  = pfcStrip->getPtrCalcRes()->getPtrCalcResPass(pn);
      sn           = calcResPass->passStandNo();
      calcResStand = pfcStrip->getPtrCalcRes()->getPtrCalcResStand(sn);

      // [N] roll force
      standDat.rollingForce = calcResPass->rollForce();
      *deB << calcResPass->rollForce() << " "
      << calcResPass->rollForcePre() << " "
      << calcResPass->rollForceHead();
      deB->info();

      // stand activ
      if (calcResStand->isActive())
      {
        standDat.isActive = 1;
      }
      else
      {
        standDat.isActive = 0;
      }
      plantStand = pfcMill->getPtrStandData(sn)->getPtrPlantDataStand();

      // shift mode wr
      if(plantStand->shiftMode() == 1)
        standDat.pairCrossAllowed = plantStand->shiftMode();
      else
        standDat.pairCrossAllowed = 0;

      // pressure cyl. support mode
      standDat.pcsm      = plantStand->pressCylSupMod();

      // take over stand data
      m_setup->setStandData(sn, standDat);

      ownFrictionModels[sn].setEntryStrip(&m_setup->getStrip(sn));
      ownFrictionModels[sn].setValue(0, 0.6491);
      ownFrictionModels[sn].setValue(1, 1.6790);
      m_setup->getStand(sn).setFrictionModel(&ownFrictionModels[sn]);
    }
  }   // end try
  catch (BCException& ex)
  {
    DE_BUG << "caught error preset pfc calc res: " << ex.what() << ERR;
    pfcStrip->setCalcFault(SetCalcRes, UNDEF_STAND,"pfc");
    return PSC_ERROR * SetCalcRes;
  }
  catch (...)
  {
    DE_BUG << "caught unknown error pfc calc res: " << ERR;
    pfcStrip->setCalcFault(SetCalcRes, UNDEF_STAND,"pfc");
    return PSC_ERROR * SetCalcRes;
  }
  return returnW;
}

short PfcCalculation::setPfcStrategyData()
{
  short returnW = PSC_OK;
  DmLPPass * lpPass;
  DmMillStratStand  * lpPassMill;
  DmCalcResults * calcResults = pfcStrip->getPtrCalcRes();
  DmCalcResMill * calcResMill = calcResults->getPtrCalcResMill();
  DmCalcResPass * calcResPass ;
  int sn = 0;

  // set furnace number
  int furnaceNo = pfcStrip->getPtrPrimaryData()->getPtrStripData()->slFurnaceNoZi() != ZI_VALUE_NOT_AVAILABLE ? pfcStrip->getPtrPrimaryData()->getPtrStripData()->slFurnaceNo()  : 0;
  int casterNo  = (int)(pfcStrip->getPtrPrimaryData()->getPtrStripData()->slCasterLineZi() != ZI_VALUE_NOT_AVAILABLE ? pfcStrip->getPtrPrimaryData()->getPtrStripData()->slCasterLine()  : 0);
  DE_BUG << "furnNo: " << furnaceNo << "  || castNo: " << casterNo << INFO;

  // set furnace number
  m_setup->setFurnaceNumber(furnaceNo);

  // Mic 20070605 leider fangen Ofen- und Caster-Nummer nicht bei 0 an...
  if (furnaceNo > 0)
    furnaceNo--;
  if (casterNo > 0)
    casterNo--;

  try
  {
    for (unsigned int pn = 0; pn < MAX_NO_PASSES; pn++)
    {
      lpPass      = pfcStrip->getPtrStrategyData()->getPtrLoadPlPass(pn);
      calcResPass = calcResults->getPtrCalcResPass(pn);
      sn          = calcResPass->passStandNo();
      lpPassMill  = pfcStrip->getPtrStrategyData()->getPtrMillStratStand(sn);

      // set operator observed unflatness
      if (lpPassMill->observedFlatZi(casterNo)  != ZI_VALUE_NOT_AVAILABLE)
      {
        double obsFlat = -lpPassMill->observedFlat(casterNo);
        if (obsFlat > 100)
          obsFlat = 100;
        if (obsFlat < -100)
          obsFlat = -100;

        DE_BUG << "observed flatness: " << obsFlat << INFO;
        m_setup->setUnflatness(pn, obsFlat / (-2e1 / 1e0));
      }
      else
      {
        m_setup->setUnflatness(pn, 0.);
      }

    // only for testing Ra_090206
    DmPlantDataStand * plantStand ;

    plantStand = pfcMill->getPtrStandData(sn)->getPtrPlantDataStand();

    DE_BUG << "shift workRollData for stand " << pn << ": " << workRollData[sn]->getShiftingAllowed() << INFO;
    DE_BUG << "plantStand shifting for stand " << pn << ": " << plantStand->shiftingAl(WR) << INFO;

      // Mic 20060410 start: add cyclic shifting for Stand 1 to 6
      if ( (/*pn == 0 || pn == 1 || pn == 2 ||  pn == 3 || pn == 4 ||*/ pn == 5 || pn == 6) &&
           ((m_setup->getStand(pn).getRoll(0)->getShapeCoefficients()[0] == 0) &&
           (m_setup->getStand(pn).getRoll(0)->getShapeCoefficients()[2] == 0) &&
            plantStand->shiftingAl(WR) )
         )
      {
        // set cyclic shifting on / off !! uri  from mos switches  TBD
        CusPfcSetupBase::ShiftStrategy shiftStrat = CusPfcSetupBase::NoTaperInStrip;
        CusPfcSetupBase::CyclicShifting cyclStrat = CusPfcSetupBase::Regular;

        // set cycl shifting
        m_setup->setShiftStrategy(pn, shiftStrat);
        m_setup->setCyclicShifting(pn, cyclStrat);

        DE_BUG << "set cyclic shifting for stand " << pn + 1 << " to: " << cyclStrat << INFO;
      }
      else
      {
        // set cyclic shifting on / off !! uri  from mos switches  TBD
        CusPfcSetupBase::ShiftStrategy shiftStrat = CusPfcSetupBase::NoTaperRoll;
        CusPfcSetupBase::CyclicShifting cyclStrat = CusPfcSetupBase::NoCyclicShift;

        // set normal shifting
        m_setup->setShiftStrategy(pn, shiftStrat);
        m_setup->setCyclicShifting(pn, cyclStrat);
      }

      // new variable to check ghost rolling Ra_081124
      if(   !strncmp(pfcStrip->getPtrCalcRes()->meCode().extId,"GHOST",5)
         || !strncmp(pfcStrip->getPtrCalcRes()->meCode().extId,"SIWI",4)
         || !strncmp(pfcStrip->getPtrCalcRes()->meCode().extId,"SIMU",4))
      {
          m_setup->setSimulationState(true);
          DE_BUG << "set simulation state for strip: " << pfcStrip->getPtrCalcRes()->meCode().extId << " to true" << INFO;
      }
      else
      {
        m_setup->setSimulationState(false);
        DE_BUG << "set simulation state for strip: " << pfcStrip->getPtrCalcRes()->meCode().extId << " to false" << INFO;
      }

      // set the operator values
      double balanceForce = pfcMill->getPtrStandData(pn)->getPtrPlantDataStand()->balanceForce();
      if (lpPass->bendingForceZi() != ZI_VALUE_NOT_AVAILABLE)
      {
        hmi.m_correctionBending[pn].value = (lpPass->bendingForce() + balanceForce);
        hmi.m_correctionBending[pn].valid = true;
        calcResPass->setBendingForce(lpPass->bendingForce());
        calcResPass->setBendingForceSt(SetpMan);
      }
      else
      {
        hmi.m_correctionBending[pn].value = PFC_INVALID_VALUE;
        hmi.m_correctionBending[pn].valid = false;
        calcResPass->setBendingForceSt(SetpMod);
      }
      if (lpPass->cVCShiftingZi() != ZI_VALUE_NOT_AVAILABLE)
      {
        hmi.m_correctionShift[pn].value = lpPass->cVCShifting() * 1e3;
        hmi.m_correctionShift[pn].valid = true;
        calcResPass->setRollShift(lpPass->cVCShifting());
        calcResPass->setRollShiftSt(SetpMan);
      }
      else
      {
        hmi.m_correctionShift[pn].value = PFC_INVALID_INT_VALUE;
        hmi.m_correctionShift[pn].valid = false;
        calcResPass->setRollShiftSt(SetpMod);
      }
      hmi.m_correctionPairCross[pn].value = PFC_INVALID_VALUE;
      hmi.m_correctionPairCross[pn].valid = false;
      // miele_040131 added setting of HMI values
      m_setup->setHMIValues(hmi);
    }
  }
  catch (BCException& ex)
  {
    DE_BUG << "caught error preset pfc strategy data: " << ex.what() << ERR;
    pfcStrip->setCalcFault(SetStratData, UNDEF_STAND);
    return PSC_ERROR * SetStratData;
  }
  catch (...)
  {
    DE_BUG << "caught unknown error pfc strategy data: " << ERR;
    pfcStrip->setCalcFault(SetStratData, UNDEF_STAND);
    return PSC_ERROR * SetStratData;
  }
  return returnW;
}

bool PfcCalculation::doCalculate()
{
  short returnW = PSC_OK;

  // roll data
  if (!setPfcRollData())
    return false;

  // ac roll data
  if (!setPfcAcRollData())
    return false;

  // set strategy data
  if ((returnW = setPfcStrategyData()) != PSC_OK)
    return false;

  // set plant limit
  if ((returnW = setPfcPlantLimit())   != PSC_OK)
    return false;

  // set primary data
  if ((returnW = setPfcStripData())    != PSC_OK)
    return false;

  // set chemistry
  if ((returnW = setPfcChemistry())    != PSC_OK)
    return false;

  // set "preset" pass and stand data
  if ((returnW = setPfcCalcRes())      != PSC_OK)
    return false;

  // info path for log file
  char path[200];
  strncpy(path     , mosEnv->mosGetEnv("PSC_LOG_DIR"), sizeof(path));

  // debug switch
  if (pfcStrip->getPtrStrategyData()->getPtrMosSwitches()->dbgPfcINCnstr())
  {
    strcat(path, "dbgPfcINCnstr.dat");
    ofstream out4(path, ios::trunc);
    out4 << *m_setup;
    out4.close();
  }
  DE_BUG << "CALCTYPE: " << pfcStrip->getPtrCalcRes()->calcTypeMos() << INFO;

  try
  {
    DE_BUG << "Chain number: " << m_chainNumber << INFO;

    if (1 == m_chainNumber)
      m_wrapper->enableWriting();
    else
      m_wrapper->disableWriting();

    m_setup->setCalculationType(pfcStrip->getPtrCalcRes()->calcTypeMos());

    // do calculate
    m_wrapper->calculate();

    DE_BUG << "Pfc Calculation succesful " << INFO;
  }
  catch (BCException& ex)
  {
    DE_BUG << "caught calc error: " << ex.what() << ERR;
    pfcStrip->setCalcFault(PfcCalcErr, UNDEF_STAND);
    return false;
  }
  catch (...)
  {
    DE_BUG << "caught unknown error" << ERR;
    pfcStrip->setCalcFault(PfcCalcErr, UNDEF_STAND);
    return false;
  }

  // info path for log file
  strncpy(path     , mosEnv->mosGetEnv("PSC_LOG_DIR"), sizeof(path));
  if (pfcStrip->getPtrStrategyData()->getPtrMosSwitches()->dbgPfcOUTCnstr())
  {
    strcat(path, "dbgPfcOUTCnstr.dat");
    ofstream out3(path, ios::trunc);
    out3 << *m_setup;
    out3.close();
  }
  strncpy(path     , mosEnv->mosGetEnv("PSC_LOG_DIR"), sizeof(path));
  if (pfcStrip->getPtrStrategyData()->getPtrMosSwitches()->dbgPfcResult())
  {
    strcat(path, "dbgPfcResult.in");
    ofstream out2(path, ios::app);
    m_setup->storeData(out2);
  }

  // get calculation results pfc
  m_setup->getResults(pfcResults);

  // modify profile las for calculated exit profile
  int las;
  for (las = m_setup->getNoStands() - 1; las >= 0; las--)
    if (m_setup->getStand(las).isActive())
      break;

  //pfcResults.m_resProfiles[las] = m_wrapper->getEstimatedProfile();

  // take over results calcResults from pfc
  takeOverResults();

  try
  {
    // calculate setpoint values for screw down and stand
    if (!screwDown.callScrewAfterPfcRun())
      throw_BCException("preCalculationSingleMode()::ERROR calculation screw after pfc calculation ");
  }
  catch(...)
  {
    DE_BUG << "caught unknown error screw down calculation " << ERR; 
    pfcStrip->setCalcFault(ScrewDownCalc, UNDEF_STAND);
    return false;
  }
  updateResults();
  return true;
}

void PfcCalculation::updateResults()
{
  DmCalcResults  * calcResults = pfcStrip->getPtrCalcRes();
  DmCalcResPass  * calcResPass ;
  DmCalcResStand * calcResStand;
  DmTwOutStand*    twmOutStand;
  
  // loop over all passes
  for (int pn = 0; pn < MAX_NO_PASSES ; pn++)
  {
    calcResPass  = calcResults->getPtrCalcResPass(pn);

    calcResStand = calcResults->getPtrCalcResStand(calcResPass->passStandNo());

    // reset data for inactive stands
    if (calcResStand->isActive())
    {
      // [N/N] effectiveness roll force on bending force 
      calcResPass->getPtrScrewDownVal()->setDfbDfr(m_setup->getDFbdFr(pn));
    }
  }
  deB->info();
}

bool
PfcCalculation::calcFbGradient(
  double profileGradientX2, // IP [-] profile gradient X2 TW
  double profileGradientX4, // IP [-] profile gradient X4 TW
  double e_fb_x2,           // IP [m/N] efficiency bending force X2 BM
  double e_fb_x4,           // IP [m/N] efficiency bending force X4 BM
  double& fbGrad            // OP [N/m] bending force gradient
)
{
  return true;

}

bool PfcCalculation :: takeOverResults()
{
  short returnW = PSC_OK;
  DmCalcResults  * calcResults = pfcStrip->getPtrCalcRes();
  DmCalcResMill  * calcResMill = calcResults->getPtrCalcResMill();
  DmCalcResPass  * calcResPass ;
  DmCalcResStand * calcResStand;

  calcResults->setCalcResCount(calcResults->calcResCount() + 1);

  // set calculation type
  if (calcResMill->setpointType() == TEST_CALC)
  {
    calcResMill->setSetpointType(TEST_CALC_PFC);
  }
  else
  {
    calcResMill->setSetpointType(PRE_CALC_PFC);
  }

  // added for sp table supply: result of reachable profile for evaluation
  double fac;
  if (calcResMill->getPtrFMExitValues()->getPtrExitThickFm()->getPtrThickness()->valueHot() > 0.0)
  {
    fac =  calcResMill->getPtrFMExitValues()->getPtrExitThickFm()->getPtrThickness()->valueCold()
           / calcResMill->getPtrFMExitValues()->getPtrExitThickFm()->getPtrThickness()->valueHot();
  }
  else
  {
    fac = 1.0;
  }

  calcResMill->setFMExitProfileCalc(fac*pfcResults.m_targetProfiles[calcResMill->noLas()]);

  // initialize and set the bending/CVC limits
  DmLimitDataStand * limitStand;

  // loop over all passes
  for (int pn = 0; pn < MAX_NO_PASSES ; pn++)
  {
    calcResPass  = calcResults->getPtrCalcResPass(pn);

    calcResStand = calcResults->getPtrCalcResStand(calcResPass->passStandNo());

    // convert bending limits
    double balanceForce = pfcMill->getPtrStandData(pn)->getPtrPlantDataStand()->balanceForce();

    // reset data for inactive stands
    if (calcResStand->isActive())
    {
      // [N] bending force for work roll
      calcResPass->setBendingForceModOutput(pfcResults.m_setupBending[pn] - balanceForce );

      if (calcResPass->bendingForceSt() == SetpMod)
        calcResPass->setBendingForce(pfcResults.m_setupBending[pn] - balanceForce );

      limitStand = pfcMill->getPtrStandData(pn)->getPtrLimitStand();

      // [m] shifting for work roll
      calcResPass->setRollShiftModOutput(pfcResults.m_setupShift[pn] * 1.e-3);

      if (calcResPass->rollShiftSt() == SetpMod)
        calcResPass->setRollShift(pfcResults.m_setupShift[pn] * 1.e-3);

      // [m/m] calculated flatness
      calcResPass->setCalcFlat(pfcResults.m_resFlatness[pn]);

      // [m] calculated profile
      calcResPass->setCalcProfile(pfcResults.m_resProfilesHMI[pn]);
    }
    else
    {
      // [N] bending force for work roll
      calcResPass->setBendingForceModOutput(0);

      if (calcResPass->bendingForceSt() == SetpMod)
        calcResPass->setBendingForce(balanceForce);
    }
  }
  return true;
}

bool PfcCalculation::displayResults()
{
  bool result = true;
  int     standNo    ;
  int pn;
  double  helpDouble1;
  DmCalcResults  * calcResults  = pfcStrip->getPtrCalcRes();
  DmCalcResMill  * calcResMill  = calcResults->getPtrCalcResMill();
  MosMillData    * pcMill       = MosMillData    ::   GetInstance();
  DmCalcResPass  * calcResPass  ;
  DmTwOutRoll    * twmRoll      ;

  char lineText[300];
  char helpText[100];
  static char calcRunT[50];
  strcpy(calcRunT, "PFC Calculation   ");

  // set haedline
  sprintf(lineText,
          "=====================================================================================================================================");
  DE_BUG << lineText << WARN;
  sprintf(lineText,
          " ext Id  %20s  bas Id %d " , calcResults->meCode().extId, calcResults->meCode().basId);
  DE_BUG << lineText << WARN;
  sprintf(lineText,
          "=====================================================================================================================================");
  DE_BUG << lineText << WARN;
  sprintf(lineText,
          " RM data   : thick %6.2f [mm]  width  %7.1f [mm]  temp %7.1f [grdC] ",
          calcResMill->getPtrRMExitValues()->getPtrExitThickRm()->getPtrThickness()->valueCold() * 1.e3
          , calcResMill->getPtrRMExitValues()->getPtrExitWidthRm()->getPtrWidth()->valueCold() * 1.e3
          , calcResMill->getPtrRMExitValues()->getPtrExitTempRm()->getPtrTemp()->valueHot()
         );
  DE_BUG << lineText << WARN;
  sprintf(lineText,
          " FM data   : thick %6.2f [mm]  width  %7.1f [mm]  temp %7.1f [grdC] profileC40 %7.4f [mm] alloy name %12s",
          calcResMill->getPtrFMExitValues()->getPtrExitThickFm()->getPtrThickness()->valueCold()    * 1.e3
          , calcResMill->getPtrFMExitValues()->getPtrExitWidthFm()->getPtrWidth()->valueCold() * 1.e3
          , calcResMill->getPtrFMExitValues()->getPtrExitTempFm()->getPtrTemp()->valueHot()
          , calcResMill->fMExitProfileSetp() * 1.e3
          , pfcStrip->getPtrPrimaryData()->getPtrStripData()->alloyCode()
         );
  DE_BUG << lineText << WARN;
  sprintf(lineText,
          "======================|============|============|============|============|============|============|============|===================");
  DE_BUG << lineText << WARN;

  sprintf(lineText, " %21s|" , calcRunT);

  for(pn = 0; pn < MAX_NO_PASSES; pn++)
  {
    sprintf(helpText, "     F%1d     |", pn + 1);
    strcat(lineText, helpText);
  }
  sprintf(helpText, "       MH ");

  DE_BUG << lineText << WARN;
  sprintf(lineText,
          "======================|============|============|============|============|============|============|============|===================");
  DE_BUG << lineText << WARN;

  // roll force
  sprintf(lineText, "roll force       [MN] |");
  for (pn = 0; pn < MAX_NO_PASSES; pn++)
  {
    calcResPass = calcResults->getPtrCalcResPass(pn);
    sprintf(helpText, "%12.3f|", calcResPass->rollForce() * 1.e-6);
    strcat(lineText, helpText);
  }
  DE_BUG << lineText << WARN;

   //[N/N] delta bending force to delta roll force 
  sprintf(lineText, "dFbdFr            [-] |");
  for (pn = 0; pn < MAX_NO_PASSES; pn++)
  {
    calcResPass = calcResults->getPtrCalcResPass(pn);
    sprintf(helpText, "%12.3f|", (calcResPass)->getPtrScrewDownVal()->dfbDfr());
    strcat(lineText, helpText);
  }
  DE_BUG << lineText << WARN;

  // message (1 / cg) Frame
  sprintf(lineText, "dsgdF         [um/MN] |");
  for (pn = 0; pn < MAX_NO_PASSES; pn++)
  {
    calcResPass = calcResults->getPtrCalcResPass(pn);
    sprintf(helpText, "%12.3f|", (calcResPass)->getPtrScrewDownVal()->dsgDF()  * 1.e12);
    strcat(lineText, helpText);
  }
  DE_BUG << lineText << WARN;

  // message ( 1 / cg ) Bending
  sprintf(lineText, "dsbdFr        [um/MN] |");
  for (pn = 0; pn < MAX_NO_PASSES; pn++)
  {
    calcResPass = calcResults->getPtrCalcResPass(pn);
    sprintf(helpText, "%12.3f|", (calcResPass)->getPtrScrewDownVal()->dsbDFr()  * 1.e12);
    strcat(lineText, helpText);
  }
  DE_BUG << lineText << WARN;

  // message R點kbiegung der Walzen
  sprintf(lineText, "dsbdFb        [um/MN] |");
  for (pn = 0; pn < MAX_NO_PASSES; pn++)
  {
    calcResPass = calcResults->getPtrCalcResPass(pn);
    sprintf(helpText, "%12.3f|", (calcResPass)->getPtrScrewDownVal()->dsdDfb()  * 1.e12);
    strcat(lineText, helpText);
  }
  DE_BUG << lineText << WARN;

  // message cg and cgs working point (upper lower)
  sprintf(lineText, "stand module  [MN/mm] |");
  for (pn = 0; pn < MAX_NO_PASSES; pn++)
  {
    calcResPass = calcResults->getPtrCalcResPass(pn);
    sprintf(helpText, "%12.3f|", (calcResPass)->getPtrScrewDownVal()->standModule()  * 1.e-9);
    strcat(lineText, helpText);
  }
  DE_BUG << lineText << WARN;

  sprintf(lineText, "stand mod uf  [MN/mm] |");
  for (pn = 0; pn < MAX_NO_PASSES; pn++)
  {
    calcResPass = calcResults->getPtrCalcResPass(pn);
    sprintf(helpText, "%12.3f|", (calcResPass)->getPtrScrewDownVal()->standModuleDFU()  * 1.e-9);
    strcat(lineText, helpText);
  }
  DE_BUG << lineText << WARN;

  sprintf(lineText, "stand mod lf  [MN/mm] |");
  for (pn = 0; pn < MAX_NO_PASSES; pn++)
  {
    calcResPass = calcResults->getPtrCalcResPass(pn);
    sprintf(helpText, "%12.3f|", (calcResPass)->getPtrScrewDownVal()->standModuleDFL()  * 1.e-9);
    strcat(lineText, helpText);
  }
  DE_BUG << lineText << WARN;

  // screw down
  sprintf(lineText, "screw down       [mm] |");
  for (pn = 0; pn < MAX_NO_PASSES; pn++)
  {
    calcResPass = calcResults->getPtrCalcResPass(pn);
    sprintf(helpText, "%12.3f|", calcResPass->getPtrScrewDownVal()->screwDown()  * 1.e3);
    strcat(lineText, helpText);
  }
  DE_BUG << lineText << WARN;

  sprintf(lineText, "screw down pre   [mm] |");
  for (pn = 0; pn < MAX_NO_PASSES; pn++)
  {
    calcResPass = calcResults->getPtrCalcResPass(pn);
    sprintf(helpText, "%12.3f|", calcResPass->getPtrScrewDownValPre()->screwDown()  * 1.e3);
    strcat(lineText, helpText);
  }
  DE_BUG << lineText << WARN;

  //[1/N] effectiveness bending force on strip flatness (Ra_080517)
  sprintf(lineText, "dluDfb          [1/N] |");
  for (pn = 0; pn < MAX_NO_PASSES; pn++)
  {
    calcResPass = calcResults->getPtrCalcResPass(pn);
    sprintf(helpText,"%12.3f|", calcResPass->getPtrScrewDownVal()->dluDfb() * 1.e6);
    strcat(lineText, helpText);
  }
  DE_BUG << lineText << WARN;

  // [m/N] quadratic part of effectiveness bending force on roll gap ra_110622
  sprintf(lineText, "dx2dfb          [m/N] |");

  for (pn = 0; pn < MAX_NO_PASSES; pn++)
  {
    calcResPass = calcResults->getPtrCalcResPass(pn);
    sprintf(helpText,"%12.8f|", calcResPass->getPtrScrewDownVal()->dx2pDfb() * 1.e6);
    strcat(lineText, helpText);
  }
  DE_BUG << lineText << WARN;

  // part of power 4 of effectiveness bending force on roll gap ra_110622
  sprintf(lineText, "dx4Dfb          [m/N] |");

  for (pn = 0; pn < MAX_NO_PASSES; pn++)
  {
    calcResPass = calcResults->getPtrCalcResPass(pn);
    sprintf(helpText,"%12.8f|", calcResPass->getPtrScrewDownVal()->dx4pDfb() * 1.e6);
    strcat(lineText, helpText);
  }
  DE_BUG << lineText << WARN;

    // [m/N] quadratic part of effectiveness bending force on roll gap ra_110622
  sprintf(lineText, "dx2dfb model    [m/N] |");

  for (pn = 0; pn < MAX_NO_PASSES; pn++)
  {
    calcResPass = calcResults->getPtrCalcResPass(pn);
    sprintf(helpText,"%12.8f|",   m_setup->getDX2dFb(pn) * 1.e6);
    strcat(lineText, helpText);
  }
  DE_BUG << lineText << WARN;

  // part of power 4 of effectiveness bending force on roll gap ra_110622
  sprintf(lineText, "dx4Dfb model    [m/N] |");

  for (pn = 0; pn < MAX_NO_PASSES; pn++)
  {
    calcResPass = calcResults->getPtrCalcResPass(pn);
    sprintf(helpText,"%12.8f|",   m_setup->getDX4dFb(pn) * 1.e6);
    strcat(lineText, helpText);
  }
  DE_BUG << lineText << WARN;

  // message zero point plantData and calibration
  sprintf(lineText, "base point cal   [mm] |");
  for (pn = 0; pn < MAX_NO_PASSES; pn++)
  {
    calcResPass = calcResults->getPtrCalcResPass(pn);
    sprintf(helpText, "%12.3f|", pcMill->getStandPtr(calcResPass->passStandNo())->getPtrRollDataStand()->getPtrCalInfo()->calSd() * 1.e3);
    strcat(lineText, helpText);
  }
  DE_BUG << lineText << WARN;

  sprintf(lineText, "zero point plant [mm] |");
  for (pn = 0; pn < MAX_NO_PASSES; pn++)
  {
    calcResPass = calcResults->getPtrCalcResPass(pn);
    sprintf(helpText, "%12.3f|", pcMill->getStandPtr(calcResPass->passStandNo())->getPtrPlantDataStand()->screwDownZeroPoint() * 1.e3);
    strcat(lineText, helpText);
  }
  DE_BUG << lineText << WARN;

  sprintf(lineText, "zero point cal   [mm] |");
  for (pn = 0; pn < MAX_NO_PASSES; pn++)
  {
    calcResPass = calcResults->getPtrCalcResPass(pn);
    sprintf(helpText, "%12.3f|", pcMill->getStandPtr(calcResPass->passStandNo())->getPtrRollDataStand()->getPtrCalInfo()->calGS0() * 1.e3);
    strcat(lineText, helpText);
  }
  DE_BUG << lineText << WARN;

  sprintf(lineText, "twm cor sum      [mm] |");
  for (pn = 0; pn < MAX_NO_PASSES; pn++)
  {
    calcResPass = calcResults->getPtrCalcResPass(pn);
    sprintf(helpText, "%12.3f|", (calcResPass)->getPtrScrewDownVal()->rollWearCor() * 1.e3);
    strcat(lineText, helpText);
  }
  DE_BUG << lineText << WARN;

  sprintf(lineText, "twm cor idle     [mm] |");
  for (pn = 0; pn < MAX_NO_PASSES; pn++)
  {
    calcResPass = calcResults->getPtrCalcResPass(pn);
    sprintf(helpText, "%12.3f|", (calcResPass)->getPtrScrewDownVal()->sdCorIdleProg() * 1.e3);
    strcat(lineText, helpText);
  }
  DE_BUG << lineText << WARN;

  sprintf(lineText, "twm cor idle time [s] |");
  for (pn = 0; pn < MAX_NO_PASSES; pn++)
  {
    calcResPass = calcResults->getPtrCalcResPass(pn);
    sprintf(helpText, "%12.3f|", (calcResPass)->getPtrScrewDownVal()->idleTimeSdProg());
    strcat(lineText, helpText);
  }
  DE_BUG << lineText << WARN;

  // total strech frame pack roll pack
  sprintf(lineText, "frame expansion  [mm] |");
  for (pn = 0; pn < MAX_NO_PASSES; pn++)
  {
    calcResPass = calcResults->getPtrCalcResPass(pn);
    sprintf(helpText, "%12.3f|", (calcResPass)->getPtrScrewDownValPre()->framePackExpansion() * 1.e3);
    strcat(lineText, helpText);
  }
  DE_BUG << lineText << WARN;

  sprintf(lineText, "roll  expansion  [mm] |");
  for (pn = 0; pn < MAX_NO_PASSES; pn++)
  {
    calcResPass = calcResults->getPtrCalcResPass(pn);
    sprintf(helpText, "%12.3f|", (calcResPass)->getPtrScrewDownValPre()->rollPackExpansion() * 1.e3);
    strcat(lineText, helpText);
  }
  DE_BUG << lineText << WARN;

  /*sprintf ( lineText, "screw down cor   [mm] |" );

  for (pn = 0; pn < MAX_NO_PASSES; pn++)
  {
    calcResPass = calcResults->getPtrCalcResPass(pn);
    sprintf ( helpText, "%12.6f|", ( calcResPass )->getPtrCofaPassModReq()->cofaScrewDown() * 1.e3 );
    strcat(lineText, helpText);
  }
  DE_BUG << lineText << WARN;*/

  sprintf(lineText,
          "======================|============|============|============|============|============|============|============|=========================");
  DE_BUG << lineText << WARN;

  sprintf(lineText, "strip thickness  [mm] |");

  for (pn = 0; pn < MAX_NO_PASSES; pn++)
  {
    calcResPass = calcResults->getPtrCalcResPass(pn);
    sprintf(helpText, "%12.3f|", calcResPass->exitThickness()  * 1.e3);
    strcat(lineText, helpText);
  }
  DE_BUG << lineText << WARN;

  // profile
  sprintf(lineText, "strip profile    [mm] |");
  for (pn = 0; pn < MAX_NO_PASSES; pn++)
  {
    calcResPass = calcResults->getPtrCalcResPass(pn);
    sprintf(helpText, "%12.3f|", calcResPass->calcProfile()  * 1.e3);
    strcat(lineText, helpText);
  }
  DE_BUG << lineText << WARN;

  // profile relative
  sprintf(lineText, "strip profile   [prz] |");
  for (pn = 0; pn < MAX_NO_PASSES; pn++)
  {
    calcResPass = calcResults->getPtrCalcResPass(pn);
    if (calcResPass->exitThickness() > 0.0)
    {
      sprintf(helpText, "%12.3f|", calcResPass->calcProfile() / calcResPass->exitThickness()  * 1.e2);
    }
    else
    {
      sprintf(helpText, "%12.3f|", 0.0);
    }
    strcat(lineText, helpText);
  }
  DE_BUG << lineText << WARN;

  // flatness
  sprintf(lineText, "strip flat     [ym/m] |");
  for (pn = 0; pn < MAX_NO_PASSES; pn++)
  {
    calcResPass = calcResults->getPtrCalcResPass(pn);
    sprintf(helpText, "%12.3f|", calcResPass->calcFlat() * 1.e6);
    strcat(lineText, helpText);
  }
  DE_BUG << lineText << WARN;

  // roll shift
  sprintf(lineText, "roll shift       [mm] |");
  for (pn = 0; pn < MAX_NO_PASSES; pn++)
  {
    calcResPass = calcResults->getPtrCalcResPass(pn);
    sprintf(helpText, "%12.3f|", calcResPass->rollShift()  * 1.e3);
    strcat(lineText, helpText);
  }
  DE_BUG << lineText << WARN;

  sprintf(lineText, "roll shiftMod    [mm] |");
  for (pn = 0; pn < MAX_NO_PASSES; pn++)
  {
    calcResPass = calcResults->getPtrCalcResPass(pn);
    sprintf(helpText, "%12.3f|", calcResPass->rollShiftModOutput()  * 1.e3);
    strcat(lineText, helpText);
  }
  DE_BUG << lineText << WARN;

  // roll bending
  sprintf(lineText, "bending force    [MN] |");
  for (pn = 0; pn < MAX_NO_PASSES; pn++)
  {
    calcResPass = calcResults->getPtrCalcResPass(pn);
    sprintf(helpText, "%12.3f|", calcResPass->bendingForce() * 1.e-6);
    strcat(lineText, helpText);
  }
  DE_BUG << lineText << WARN;

  sprintf(lineText, "bending forceMod [MN] |");
  for (pn = 0; pn < MAX_NO_PASSES; pn++)
  {
    calcResPass = calcResults->getPtrCalcResPass(pn);
    sprintf(helpText, "%12.3f|", calcResPass->bendingForceModOutput() * 1.e-6);
    strcat(lineText, helpText);
  }
  DE_BUG << lineText << WARN;

  sprintf(lineText,
          "======================|=====================================================================================================[]=============");
  DE_BUG << lineText << WARN;

  // set roll data
  sprintf(lineText, "WR diameter       [m] |");
  for (pn = 0; pn < MAX_NO_PASSES; pn++)
  {
    standNo = pfcStrip->getPtrCalcRes()->getPtrCalcResPass(pn)->passStandNo();
    helpDouble1 =   pfcMill->getPtrStandData(standNo)->getPtrRollDataStand()->getPtrRollData(WR_T)->diameter();

    sprintf(helpText, "%12.4f|", helpDouble1);
    strcat(lineText, helpText);
  }
  DE_BUG << lineText << WARN;

  // set roll temperature WR
  sprintf(lineText, "WR mean temp    [Grd] |");
  for (pn = 0; pn < MAX_NO_PASSES; pn++)
  {
    standNo = pfcStrip->getPtrCalcRes()->getPtrCalcResPass(pn)->passStandNo();
    twmRoll  = acMill->getPtrAcValues()->getPtrTwOut()->getPtrTwOutStand(standNo)->getPtrTwOutRoll(WR) ;
    helpDouble1 =   twmRoll->tmTMean();

    sprintf(helpText, "%12.4f|", helpDouble1);
    strcat(lineText, helpText);
  }
  DE_BUG << lineText << WARN;

  // set roll crown temp
  sprintf(lineText, "WR temp crown    [mm] |");
  for (pn = 0; pn < MAX_NO_PASSES; pn++)
  {
    standNo = pfcStrip->getPtrCalcRes()->getPtrCalcResPass(pn)->passStandNo();
    twmRoll  = acMill->getPtrAcValues()->getPtrTwOut()->getPtrTwOutStand(standNo)->getPtrTwOutRoll(WR) ;
    helpDouble1 =   twmRoll->tmCrown() * 1.e3;

    sprintf(helpText, "%12.4f|", helpDouble1);
    strcat(lineText, helpText);
  }
  DE_BUG << lineText << WARN;

  // set roll crown wear
  sprintf(lineText, "WR wear crown    [mm] |");
  for (pn = 0; pn < MAX_NO_PASSES; pn++)
  {
    standNo = pfcStrip->getPtrCalcRes()->getPtrCalcResPass(pn)->passStandNo();
    twmRoll  = acMill->getPtrAcValues()->getPtrTwOut()->getPtrTwOutStand(standNo)->getPtrTwOutRoll(WR) ;
    helpDouble1 =   twmRoll->wmCrown() * 1.e3;

    sprintf(helpText, "%12.4f|", helpDouble1);
    strcat(lineText, helpText);
  }
  DE_BUG << lineText << WARN;

  sprintf(lineText,
          "======================|=====================================================================================================[]=============");
  DE_BUG << lineText << WARN;

  return result;
}
